# file: chaos.gfs
# author: Jess Robertson (based on code from Gerris examples)
#         CSIRO Earth Science and Resource Engineering
# date:   Tuesday February 26, 2013
#
# description: Simulation of thread formation in a laminar chaotic flow field. 
#
#   Parameters to be defined are:
#
#       viscosity_ratio - the viscosity ratio between the sulfide and magma
#       reynolds_number - the Reynolds number for the simulation
#       capillary_number - the capillary number for the simulation
#       min_level - the minimum resolution (3 works well)
#       max_level - the finest resolution (7-8 is good for a desktop)
#       period - the period of the vortex blinking
#       end_time - the end time for the simulation
#
#   Ratios are sulfide / magma. Don't modify this script directly, see
#   configure.py to set parameters etc.
#
1 0 GfsSimulation GfsBox GfsGEdge {} {
    # Function definitions etc
    Global {
        // Parameters
        static double volume = 8. * M_PI * M_PI * M_PI;
        static double offset = 0.5 * M_PI;
        static double droplet_radius = 0.2 * M_PI;
        static double vortex_strength = 0.25;

        // Physical properties
        static double viscosity(double tracer) {
            return (1 + (viscosity_ratio - 1) * tracer)
                   / ( (float) reynolds_number );
        }

        // Tracer distribution
        static double tracer_init(double x, double y) {
            double radius_sq = x * x + y * y;
            return radius_sq < droplet_radius ? 1 : 0;
        }

        // Streamfunction
        static double tick(double t) {
            int step = floor(2 * t / period);
            return step % 2;
        }
        static double tock(double t) {
            int step = floor(2 * t / period);
            return (step - 1) % 2;
        }
        static double vortex_x(double x0, double y0, double x, double y) {
            double radius_sq = (x - x0) * (x - x0) + (y - y0) * (y - y0);
            return vortex_strength * y / radius_sq;
        }
        static double vortex_y(double x0, double y0, double x, double y) {
            double radius_sq = (x - x0) * (x - x0) + (y - y0) * (y - y0);
            return vortex_strength * x / radius_sq;
        }
    }

    # Set up sulfide and magma properties
    Refine 5
    RefineSurface 9 (ellipse(x, y, droplet_radius, droplet_radius))
    VariableTracerVOF T
    VariableCurvature K T Kmax
    PhysicalParams {
        L = 2. * M_PI
        alpha = 1
    }
    SourceViscosity viscosity(T)
    SourceTension T 0.01 K

    # Initialize the velocity and tracer
    Init {} {
        T = tracer_init(x, y)
    }

    # Set up forcings
    Source U {
        return tick(t) * vortex_x(offset, offset, x, y) + 
               tock(t) * vortex_x(-offset, -offset, x, y);
    }
    Source V {
        return tick(t) * vortex_y(offset, offset, x, y) + 
               tock(t) * vortex_y(-offset, -offset, x, y);
    }

    ## ADAPTIVITY
    # We want adaptivity around the fluid interface and the velocity field
    # Adapt according to interface curvature. 
    AdaptFunction { istep = 1 } {
        cmax = 0.2
        minlevel = min_level
        maxlevel = max_level
    } (T > 0 && T < 1)
    AdaptError { istart = 5 istep = 1 } {
        cmax = 5e-2
        maxlevel = max_level
    } U
    AdaptError { istart = 5 istep = 1 } {
        cmax = 5e-2
        maxlevel = max_level
    } V

    # Balance the number of elements across parallel subdomains at every
    # 5 timesteps if the imbalance is larger than 0.1 (i.e. 10% difference
    # between the largest and smallest subdomains).
    EventBalance { istep = 5 } 0.1

    # Output of solution information/data
    Time { end = end_time }
    OutputProgress { istep = 1 } stderr
    OutputTime { istep = 1 } turbulent_breakup.log
    OutputBalance { istep = 1 } turbulent_breakup.log
    OutputSimulation {
        start = 0 step = simulation_output_times
    } simulation_%09.3f.gfs
}
GfsBox {
    left = Boundary {
        BcDirichlet V 0
    }
    right = Boundary {
        BcDirichlet V 0
    }
    top = Boundary {
        BcDirichlet U 0
    }
    bottom = Boundary {
        BcDirichlet U 0
    }
}
